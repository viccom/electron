From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Anonymous <anonymous@electronjs.org>
Date: Thu, 20 Sep 2018 17:45:21 -0700
Subject: browser_plugin_wheel.patch


diff --git a/content/renderer/browser_plugin/browser_plugin.cc b/content/renderer/browser_plugin/browser_plugin.cc
index 4d8251069ae9a45e1be22fa03f23b3196116b612..fbd5cc8099629971d670d087fdee89204e3137e3 100644
--- a/content/renderer/browser_plugin/browser_plugin.cc
+++ b/content/renderer/browser_plugin/browser_plugin.cc
@@ -656,15 +656,11 @@ blink::WebInputEventResult BrowserPlugin::HandleInputEvent(
 
   DCHECK(!blink::WebInputEvent::IsTouchEventType(event.GetType()));
 
-  // With direct event routing turned on, BrowserPlugin should almost never
-  // see wheel events any more. The two exceptions are (1) scroll bubbling, and
-  // (2) synthetic mouse wheels generated by touchpad GesturePinch events on
-  // Mac, which always go to the mainframe and thus may hit BrowserPlugin if
-  // it's in a top-level embedder. In both cases we should indicate the event
-  // as not handled (for GesturePinch on Mac, indicating the event has been
-  // handled leads to touchpad pinch not working).
-  if (event.GetType() == blink::WebInputEvent::kMouseWheel)
-    return blink::WebInputEventResult::kNotHandled;
+  if (event.GetType() == blink::WebInputEvent::kMouseWheel) {
+    auto wheel_event = static_cast<const blink::WebMouseWheelEvent&>(event);
+    if (wheel_event.resending_plugin_id == browser_plugin_instance_id_)
+      return blink::WebInputEventResult::kNotHandled;
+  }
 
   if (blink::WebInputEvent::IsGestureEventType(event.GetType())) {
     auto gesture_event = static_cast<const blink::WebGestureEvent&>(event);
